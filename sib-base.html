<script type="text/javascript" src="https://cdn.happy-dev.fr/LDP-framework/ldpframework.js"></script>

<script>
    const store = new MyStore({context: "https://cdn.happy-dev.fr/owl/hdcontext.jsonld", defaultSerializer: "application/ld+json"});
    
    class SIBBase extends HTMLElement {
        static get observedAttributes() { return ['data-src']; }
        
        attributeChangedCallback(attribute, oldValue, newValue) {
            if(attribute == "data-src") {
                this.empty();
                
                // brings a loader out if the attribute is set
                if(this.hasAttribute('loader-id'))
                    document.getElementById(this.getAttribute('loader-id')).style.display = 'block';
                
                // gets the data through the store 
                if(newValue) store.get(newValue+this.idSuffix).then(resource => {
                    this.empty();
                    this.resource = resource;
                    this.populate();
                    if(this.hasAttribute('loader-id'))
                        document.getElementById(this.getAttribute('loader-id')).style.display = 'none';
                });
            }
        }
        empty() {
            //this method should be implemented by descending components to remove all content
            throw "Not Implemented";
        }
        connectedCallback() {
            if(this.resource) this.populate();
        }
        get isContainer() {
            return ('ldp:contains' in this.resource);
        }
        get next() {
            return this.getAttribute('next');
        }
        get idSuffix() { // attribute added to the id given as data-src
            if(this.hasAttribute('id-suffix'))
                return this.getAttribute('id-suffix') + '/';
            else return '';
        }
    }
    
    const SIBWidgetMixin = superclass => class extends superclass {
        get div() {
            if(this._div) return this._div;
            this._div = document.createElement('div');
            this.appendChild(this._div);
            return this._div;
        }
        getSet(field) {
            return this.getAttribute("set-"+field).split(',').map(s => s.trim());
        }
        get fields() {
            if(this.dataset.fields) return this.dataset.fields.split(',').map(s => s.trim());
            
            const resource = this.isContainer ? this.resource['ldp:contains'][0] : this.resource;
            return Object.keys(resource).filter(prop => !prop.startsWith("@"));
        }
        isSet(field) {
            return this.hasAttribute("set-"+field);
        }
        getValue(field) {
            if(this.hasAttribute("value-"+field)) return this.getAttribute("value-"+field);
            return this.resource[field];
        }
        empty() {
            while (this.div.firstChild) this.div.removeChild(this.div.firstChild);
        }
        getWidget(field) {
            return this.getAttribute("widget-"+field) || this.defaultWidget;
        }
        widgetAttributes(field) {
            return {
                value: this.getValue(field),
                name: field
            };
        }
        appendWidget(field, parent) {
            if(!parent) parent = this;
            
            if(this.isSet(field)) {
                const div = document.createElement("div");
                div.setAttribute('name', field);
                parent.appendChild(div);
                for(let item of this.getSet(field))
                    this.appendWidget(item, div);
            } else {
                const widget = document.createElement(this.getWidget(field));
                const attributes = this.widgetAttributes(field);
                for(let name of Object.keys(attributes))
                    widget[name] = attributes[name];
                parent.appendChild(widget);
            }
        }
    };
    
    const SIBListMixin = superclass => class extends superclass {
        constructor() {
            super();
            this._filters={};
            this._filtersAdded = false;
        }
        get filters() {
            return this._filters;
        }
        set filters(filters) {
            this._filters = filters;
            if(this.resource) {
                this.empty();
                this.populate();
            }
        }
        listResources() {
            if(!this.isContainer) return [];
            if(Array.isArray(this.resource['ldp:contains'])) return this.resource['ldp:contains'];
            return [this.resource['ldp:contains']];
        }
        matchValue(propertyValue, filterValue) {
            if(filterValue == '') return true;
            if(Array.isArray(propertyValue))
                return propertyValue.reduce((initial, value) => initial || this.matchValue(value, filterValue), false);
            if(propertyValue['@id']) //search in ids
                return propertyValue['@id'] == filterValue;
            if(typeof propertyValue === 'number' || propertyValue instanceof Number) //check if integer match
                return propertyValue == filterValue;
            if(typeof propertyValue === 'string' || propertyValue instanceof String) //search in strings
                return propertyValue.toLowerCase().indexOf(filterValue.toLowerCase()) != -1;
            return false;
        }
        matchFilter(resource, filter, value) {
            if(this.isSet(filter)) // for sets, return true if it matches at least one of the fields
                return this.getSet(filter).reduce((initial, field) => initial || this.matchFilter(resource, field, value), false);
            return this.matchValue(resource[filter], value);
        }
        matchFilters(resource) {
            //return true if all filters values are contained in the corresponding field of the resource
            return Object.keys(this.filters).reduce((initial, filter) => initial && this.matchFilter(resource, filter, this.filters[filter]), true);
        }
        get resources() {
            return this.listResources().filter(this.matchFilters.bind(this));
        }
        filterList(filters) {
            this.filters = filters;
        }
        appendFilters() {
            const formElt = document.createElement('sib-form');
            formElt.resource = this.resource;
            formElt.save = this.filterList.bind(this);
            formElt.change = this.filterList.bind(this);
            formElt.dataset.fields = this.getAttribute("search-fields");
            formElt.setAttribute('reset', '');
            
            //displays applied filter values in the form
            for(let filter of Object.keys(this.filters))
                if(formElt.dataset.fields.indexOf(filter)!=-1) 
                    formElt.setAttribute("value-"+filter, this.filters[filter]);
            
            //pass range attributes
            for(let field of formElt.fields)
                if(this.hasAttribute("search-range-"+field))
                    formElt.setAttribute("range-"+field, this.getAttribute("search-range-"+field));
            
            if(this.shadowRoot)
                this.shadowRoot.insertBefore(formElt, this.shadowRoot.firstChild);
            else
                this.insertBefore(formElt, this.firstChild);
            
            this._filtersAdded = true;
        }
        appendSingleElt() {
            this.appendChildElt(this.resource);
        }
        populate() {
            if(this.isContainer) {
                if(!this._filtersAdded && this.hasAttribute("search-fields")) this.appendFilters();
                for(let resource of this.resources) this.appendChildElt(resource);
            }
            else
                this.appendSingleElt();
        }
    };
</script>
<link rel="import" href="sib-form.html" />
